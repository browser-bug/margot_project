import os                                # for creating the path
import errno                             # for checking before creating a path


from .generate_utility import generate_start_monitor_signature
from .generate_utility import generate_stop_monitor_signature
from .generate_utility import generate_update_signature



def generate_block_body( block_model, op_list, cc ):
	"""
	Generates the per block code
	"""

	cc.write('\n\n// The interface for the managed block "{0}"\n'.format(block_model.block_name))

	# write the macro for the managed file
	if block_model.state_models:
		cc.write('#ifndef BLOCK_{0}_AUTOTUNED\n'.format(block_model.block_name.upper()))
		cc.write('#define BLOCK_{0}_AUTOTUNED\n'.format(block_model.block_name.upper()))
		cc.write('#endif // BLOCK_{0}_AUTOTUNED\n'.format(block_model.block_name.upper()))

	# write the update function
	cc.write('\n\nint margot_{0}_{1};\n'.format(block_model.block_name, generate_update_signature(block_model, c_language = True)))


	# write the start_monitor function
	cc.write('\n\nvoid margot_{0}_{1};\n'.format(block_model.block_name, generate_start_monitor_signature(block_model)))


	# write the log function
	cc.write('\n\nvoid margot_{0}_log( void );\n'.format(block_model.block_name))


	# write the stop_monitor function
	cc.write('\n\nvoid margot_{0}_{1};\n'.format(block_model.block_name, generate_stop_monitor_signature(block_model)))

	# write the configuration applied function
	cc.write('\n\nvoid margot_{0}_configuration_applied( void );\n'.format(block_model.block_name))
	cc.write('\n\nvoid margot_{0}_configuration_rejected( void );\n'.format(block_model.block_name))

	# write the change state function
	cc.write('\n\nvoid margot_{0}_change_state( const char* new_state );\n'.format(block_model.block_name))

	# write the block macro
	cc.write('\n\n#define MARGOT_MANAGED_BLOCK_{0} \\\n'.format(block_model.block_name.upper()))
	cc.write('if (margot_{0}_{1}) {{\\\n'.format(block_model.block_name, generate_update_signature(block_model, True)))
	if block_model.state_models:
		if block_model.configure_function:
			cc.write('{0}({1});\\\n'.format(block_model.configure_function, ', '.join(x.var_name for x in block_model.software_knobs)))
		cc.write('margot_{0}_configuration_applied(); }}\\\n'.format(block_model.block_name))
	else:
		cc.write('}\\\n')
	cc.write('margot_{0}_{1};\\\n'.format(block_model.block_name, generate_start_monitor_signature(block_model, True)))
	cc.write('for(int flag = 1; flag == 1; flag = 0, margot_{0}_{1} )'.format(block_model.block_name, generate_stop_monitor_signature(block_model, True)))

	cc.write('\n\n')


	# write the function that set the value of the goal
	for goal_model in block_model.goal_models:
		goal_type = 'double'
		cc.write('\nvoid margot_{0}_goal_{1}_set_value(const {2} new_value);\n'.format(
		block_model.block_name,
		goal_model.name,
		goal_type,
		))


	cc.write('\n\n')

	# write the translating function
	if op_list:
		for string_param_name in op_list.translator:

			# write the function to convert from str to int
			cc.write('\nvoid margot_{0}_knob_{1}_int2str(const int numeric_value, char const ** string_value);\n'.format(block_model.block_name, string_param_name.lower()))
			cc.write('void margot_{0}_knob_{1}_str2int(int* numeric_value, const char* string_value);\n'.format(block_model.block_name, string_param_name.lower()))



	# put some ending spacing
	cc.write('\n\n')











def generate_margot_h( block_models, op_lists, output_folder ):
	"""
	This function generates the actual margot source files
	"""


	# open the output file
	with open(os.path.join(output_folder, 'margot.h'), 'w') as cc:

		cc.write('#ifndef MARGOT_C_HEADER_H\n')
		cc.write('#define MARGOT_C_HEADER_H\n')

		# put some new lines
		cc.write('\n\n')
		cc.write('#include <stddef.h>\n')
		cc.write('#include <inttypes.h>\n')
		cc.write('\n\n')

		# write the disclaimer
		cc.write('\n\n\n/**\n')
		cc.write(' * WARNING:\n')
		cc.write(' * This file is autogenerated from the "margotcli" utility function.\n')
		cc.write(' * Any changes to this file might be overwritten, thus in order to \n')
		cc.write(' * perform a permanent change, please update the configuration file \n')
		cc.write(' * and re-generate this file. \n')
		cc.write(' */ \n\n\n')


		# generate the code block-specific code
		for block_name in block_models:
			if block_name in op_lists:
				generate_block_body(block_models[block_name], op_lists[block_name], cc)
			else:
				generate_block_body(block_models[block_name], None, cc)


		cc.write('\n\n// The global initialization method\n')


		# ----------- generate the init function signature
		cc.write('\n\nvoid margot_init( ')

		# get all the creation parameters
		creation_parameters = []
		monitor_models = []
		for block_name in block_models:
			monitor_models.extend( block_models[block_name].monitor_models )
		for monitor in monitor_models:
			creation_parameters.extend( monitor.creation_parameters )

		# compose the parameter list
		signature = ', '.join(['{0} {1}'.format(x.var_type, x.var_name) for x in creation_parameters if x.var_name])
		if not signature:
			signature = 'void'

		cc.write('{0} );\n'.format(signature))




		# write some trailer spaces
		cc.write('\n\n')
		cc.write('#endif // MARGOT_C_HEADER_H\n\n')
