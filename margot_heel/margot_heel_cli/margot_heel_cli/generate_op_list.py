import os                                # for creating the path
import errno                             # for checking before creating a path




def generate_op_lists( op_lists, output_folder, block_models ):
  """
  This function generates the actual margot source files
  """



  for block_name in op_lists:

    # get all the operating points list for the current block
    op_list_dic = op_lists[block_name]

    # get a reference for the first list (to get the translation dictionaries)
    first_op_list = op_list_dic[list(op_list_dic.keys())[0]]

    # get the sorted list of available data features
    op_features = sorted(op_list_dic.keys())


    # open the output file
    with open(os.path.join(output_folder, 'op_list.{0}.cc'.format(block_name)), 'w') as cc:


      # write the header
      cc.write('#include <vector>\n')
      cc.write('#include "margot_op_struct.hpp"\n')
      cc.write('#include <margot/operating_point.hpp>\n')

      # write the disclaimer
      cc.write('\n\n\n/**\n')
      cc.write(' * WARNING:\n')
      cc.write(' * This file is autogenerated from the "margotcli" utility function.\n')
      cc.write(' * Any changes to this file might be overwritten, thus in order to \n')
      cc.write(' * perform a permanent change, please update the configuration file \n')
      cc.write(' * and re-generate this file. \n')
      cc.write(' */ \n\n\n')

      # write the margot namespace begin
      cc.write('namespace margot {\n')


      # write the begin of the namespace
      cc.write('\n\tnamespace {0} {{\n'.format(block_name))

      # write the translation hash map
      for string_param_name in first_op_list.translator:

        # write the function to convert from str to int
        cc.write('\n\t\tstd::unordered_map<std::string,int> knob_{0}_str2int = {{\n'.format(string_param_name.lower()))
        for value_string in first_op_list.translator[string_param_name]:
          cc.write('\t\t\t{{"{0}", {1}}},\n'.format(value_string, first_op_list.translator[string_param_name][value_string]))
        cc.write('\t\t};')
        cc.write('\n\t\tstd::unordered_map<int,std::string> knob_{0}_int2str = {{\n'.format(string_param_name.lower()))
        for value_string in first_op_list.translator[string_param_name]:
          cc.write('\t\t\t{{{1}, "{0}"}},\n'.format(value_string, first_op_list.translator[string_param_name][value_string]))
        cc.write('\t\t};')



      # get the list of sw knob and metrics
      knob_list = sorted(first_op_list.ops[0].knobs.keys())
      metric_list = sorted(first_op_list.ops[0].metrics.keys())
      metrics_are_distribution = False
      for metric_model in block_models[block_name].metrics:
        if metric_model.distribution:
          metrics_are_distribution = True
          break


      # loop over all the op list for each defined input feature
      for index, feature_id in enumerate(op_features):

        # get the actual op_list
        op_list = op_list_dic[feature_id]

        # write the actual list of operating points
        cc.write('\n\n\t\tstd::vector< MyOperatingPoint > op_list{0} = {{\n'.format(index))
        for index, op_model in enumerate(op_list.ops):
          if index > 0:
            cc.write(',\n')
          cc.write('\t\t\t{{ // Operating Point {0}\n'.format(index + 1))
          values = []
          for knob_name in knob_list:
            values.append(op_model.knobs[knob_name])
          cc.write('\t\t\t\t{{ {0} }}, // The software knobs\n'.format(', '.join(str(x) for x in values)))
          values = []
          for metric_name in metric_list:
            if metrics_are_distribution:
                metric_value = 'MyMetricType({0}'.format(op_model.metrics[metric_name])
                if op_model.metrics_std:
                  metric_value = '{0}, {1})'.format(metric_value, op_model.metrics_std[metric_name])
                else:
                  metric_value = str(op_model.metrics[metric_name])
                values.append(metric_value)
            else:
                metric_value = '{0}'.format(op_model.metrics[metric_name])
                values.append(metric_value)
          cc.write('\t\t\t\t{{ {0} }}, // The metrics of interest\n'.format(', '.join(values)))
          cc.write('\t\t\t}')
        cc.write('\n\t\t};\n')


      # write the end of namespace
      cc.write('\n\t}} // namespace {0}\n'.format(block_name))


      # write the margot namespace end
      cc.write('\n} // namespace margot\n\n')
