import os                                # for creating the path
import errno                             # for checking before creating a path




def generate_op_lists( op_lists, output_folder ):
	"""
	This function generates the actual margot source files
	"""



	for block_name in op_lists:

		# get the operating point list
		op_list = op_lists[block_name]


		# open the output file
		with open(os.path.join(output_folder, 'op_list.{0}.cc'.format(block_name)), 'w') as cc:


			# write the header
			cc.write('#include <margot_op_struct.hpp>\n')
			cc.write('#include <margot/operating_point.hpp>\n')

			# write the disclaimer
			cc.write('\n\n\n/**\n')
			cc.write(' * WARNING:\n')
			cc.write(' * This file is autogenerated from the "margotcli" utility function.\n')
			cc.write(' * Any changes to this file might be overwritten, thus in order to \n')
			cc.write(' * perform a permanent change, please update the configuration file \n')
			cc.write(' * and re-generate this file. \n')
			cc.write(' */ \n\n\n')

			# write the margot namespace begin
			cc.write('namespace margot {\n')


			# write the begin of the namespace
			cc.write('\n\tnamespace {0} {{\n'.format(block_name))

			# write the translation hash map
			for string_param_name in op_list.translator:

				# write the function to convert from str to int
				cc.write('\n\t\tstd::unordered_map<std::string,int> knob_{0}_str2int = {{\n'.format(string_param_name.lower()))
				for value_string in op_list.translator[string_param_name]:
					cc.write('\t\t\t{{"{0}", {1}}},\n'.format(value_string, op_list.translator[string_param_name][value_string]))
				cc.write('\t\t};')
				cc.write('\n\t\tstd::unordered_map<int,std::string> knob_{0}_int2str = {{\n'.format(string_param_name.lower()))
				for value_string in op_list.translator[string_param_name]:
					cc.write('\t\t\t{{{1}, "{0}"}},\n'.format(value_string, op_list.translator[string_param_name][value_string]))
				cc.write('\t\t};')



			# get the list of sw knob and metrics
			knob_list = sorted(op_list.ops[0].knobs.keys())
			metric_list = sorted(op_list.ops[0].metrics.keys())

			# write the actual list of operating points
			cc.write('\n\n\t\toperating_points_t op_list = {\n')
			for index, op_model in enumerate(op_list.ops):
				if index > 0:
					cc.write(',\n')
				cc.write('\t\t\t{{ // Operating Point {0}\n'.format(index + 1))
				values = []
				for knob_name in knob_list:
					values.append(op_model.knobs[knob_name])
				cc.write('\t\t\t\t{{ {0} }}, // The software knobs\n'.format(', '.join(str(x) for x in values)))
				values = []
				for metric_name in metric_list:
					values.append(op_model.metrics[metric_name])
				cc.write('\t\t\t\t{{ {0} }}, // The metrics of interest\n'.format(', '.join(str(x) for x in values)))
				cc.write('\t\t\t}')
			cc.write('\n\t\t};\n')


			# write the end of namespace
			cc.write('\n\t}} // namespace {0}\n'.format(block_name))


			# write the margot namespace end
			cc.write('\n} // namespace margot\n\n')
