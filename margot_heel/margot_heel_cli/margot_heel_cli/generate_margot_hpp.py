import os                                # for creating the path
import errno                             # for checking before creating a path


from .generate_utility import generate_start_monitor_signature
from .generate_utility import generate_stop_monitor_signature
from .generate_utility import generate_update_signature



def generate_block_body( block_model, op_lists, cc ):
	"""
	Generates the per block code
	"""

	# write the begin of the namespace
	cc.write('\n\n\tnamespace {0} {{\n'.format(block_model.block_name))

	# write all the monitors
	if block_model.monitor_models:

		# open the monitor namespace
		cc.write('\n\t\tnamespace monitor {\n')

		# loop over the monitor
		for monitor_model in block_model.monitor_models:
			cc.write('\t\t\textern {0} {1};\n'.format(monitor_model.monitor_class, monitor_model.monitor_name))

		# close the monitor namespace
		cc.write('\t\t} // namespace monitor\n')

	# write all the goals
	if block_model.goal_models:

		# open the goal namespace
		cc.write('\n\t\tnamespace goal {\n')

		# loop over the goals
		for goal_model in block_model.goal_models:
			cc.write('\t\t\textern goal_t {0};\n'.format(goal_model.name))

		# close the goal namespace
		cc.write('\t\t} // namespace goal\n')

	# write the manager
	cc.write('\n\n\t\textern asrtm_t manager;\n\n\n')

	# write the list of operating points
	for op_list_name in op_lists:
		if block_model.block_name == op_list_name:
			cc.write('\n\n\t\textern operating_points_t op_list;\n\n\n')

	# write all the exposed variables from the monitors
	for monitor_model in block_model.monitor_models:
		for exposed_var_what in monitor_model.exposed_metrics:
			cc.write('\n\t\textern double {0};\n'.format(monitor_model.exposed_metrics[exposed_var_what]))

	# write the update function
	cc.write('\n\n\t\tbool {0};\n'.format(generate_update_signature(block_model)))


	# write the start_monitor function
	cc.write('\n\n\t\tvoid {0};\n'.format(generate_start_monitor_signature(block_model)))


	# write the stop_monitor function
	cc.write('\n\n\t\tvoid {0};\n'.format(generate_stop_monitor_signature(block_model)))


	# write the log function
	cc.write('\n\n\t\tvoid log( void );\n')


	# write the block macro
	cc.write('\n\n#ifndef MARGOT_MANAGED_BLOCK_{0}\n'.format(block_model.block_name.upper()))
	cc.write('#define MARGOT_MANAGED_BLOCK_{0} \\\n'.format(block_model.block_name.upper()))
	cc.write('if (margot::{0}::{1}) {{\\\n'.format(block_model.block_name, generate_update_signature(block_model, True)))
	if block_model.state_models:
		if block_model.configure_function:
			cc.write('{0}({1});\\\n'.format(block_model.configure_function, ', '.join(x.var_name for x in block_model.software_knobs)))
		cc.write('margot::{0}::manager.configuration_applied();}}\\\n'.format(block_model.block_name))
	else:
		cc.write('}\\\n')
	cc.write('margot::{0}::{1};\\\n'.format(block_model.block_name, generate_start_monitor_signature(block_model, True)))
	cc.write('for(bool flag = true; flag == true; margot::{0}::{1}, margot::{0}::log(), flag = false )\n'.format(block_model.block_name, generate_stop_monitor_signature(block_model, True)))
	cc.write('#endif // MARGOT_MANAGED_BLOCK_')
	# put some ending spacing
	cc.write('\n\n')


	# write the end of the namespace
	cc.write('\n\t}} // namespace {0}\n'.format(block_model.block_name))









def generate_margot_hpp( block_models, op_lists, output_folder ):
	"""
	This function generates the actual margot source files
	"""


	# open the output file
	with open(os.path.join(output_folder, 'margot.hpp'), 'w') as cc:


		# write the include guard
		cc.write('#ifndef MARGOT_CC_HEADER_H\n')
		cc.write('#define MARGOT_CC_HEADER_H\n')

		# get all the required headers
		required_headers = [ '<margot/asrtm.hpp>', '<cstddef>', '"margot_op_struct.hpp"' ]
		for block_name in block_models:
			required_headers.extend( x.monitor_header for x in block_models[block_name].monitor_models )
		required_headers = reversed(sorted(list(set(required_headers))))
		for h in required_headers:
			cc.write('#include {0}\n'.format(h))


		# write the output flags
		cc.write('\n\n// decomment/comment these macros to enable/disable features\n')
		cc.write('#define MARGOT_LOG_STDOUT\n')
		cc.write('#define MARGOT_LOG_FILE\n')


		# write the automanaged flag
		for block_name in block_models:
			block_model = block_models[block_name]
			if block_model.state_models:
				cc.write('#ifndef BLOCK_{0}_AUTOTUNED\n'.format(block_model.block_name.upper()))
				cc.write('#define BLOCK_{0}_AUTOTUNED\n'.format(block_model.block_name.upper()))
				cc.write('#endif // BLOCK_{0}_AUTOTUNED\n'.format(block_model.block_name.upper()))

		# put some new lines
		cc.write('\n\n')

		# write the disclaimer
		cc.write('\n\n\n/**\n')
		cc.write(' * WARNING:\n')
		cc.write(' * This file is autogenerated from the "margotcli" utility function.\n')
		cc.write(' * Any changes to this file might be overwritten, thus in order to \n')
		cc.write(' * perform a permanent change, please update the configuration file \n')
		cc.write(' * and re-generate this file. \n')
		cc.write(' */ \n\n\n')


		# write the margot namespace begin
		cc.write('namespace margot {\n')


		# generate the code block-specific code
		for block_name in block_models:
			generate_block_body(block_models[block_name], op_lists, cc)




		# ----------- generate the init function signature
		cc.write('\n\n\tvoid init( ')

		# get all the creation parameters
		creation_parameters = []
		monitor_models = []
		for block_name in block_models:
			monitor_models.extend( block_models[block_name].monitor_models )
		for monitor in monitor_models:
			creation_parameters.extend( monitor.creation_parameters )

		# compose the parameter list
		signature = ', '.join(['{0} {1}'.format(x.var_type, x.var_name) for x in creation_parameters if x.var_name])
		if not signature:
			signature = 'void'

		cc.write('{0} );\n'.format(signature))




		# write some trailer spaces
		cc.write('\n\n')

		# write the margot namespace end
		cc.write('} // namespace margot\n\n')
		cc.write('#endif // MARGOT_CC_HEADER_H\n\n')
